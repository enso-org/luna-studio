class Pair a b:
    Pair a b

class Maybe a:
    Nothing
    Just a

    def fromJust: case (self) of
        Just a: a

    def equals that: case (Pair self that) of
        Pair Nothing Nothing: True
        Pair (Just a) (Just b): a.equals b
        otherwise: False

    def map f: case (self) of
        Nothing: Nothing
        Just a: Just (f a)

    def satisfies pred: case (self) of
        Nothing: False
        Just a:  pred a

    def toJSON: case (self) of
        Just a:  "Just " + a.toJSON
        Nothing: "Nothing"

    def toList: case (self) of
        Just a: Prepend a Empty
        Nothing: Empty

class List a:
    Empty
    Prepend a (List a)

    def head: case (self) of
        Empty: Nothing
        Prepend x xs: Just x

    def tail: case (self) of
        Empty: Empty
        Prepend x xs: xs

    def prepend a: Prepend a self

    def map f: case (self) of
        Empty: Empty
        Prepend x xs: Prepend (f x) (xs.map f)

    def sequence: case (self) of
        Empty: None
        Prepend x xs: seq x xs.sequence

    def each f: self . map f . sequence

    def take i: case (self) of
        Empty: Empty
        Prepend x xs: switch (0.equals i) Empty (Prepend x (xs.take i.pred))

    def fold a f: case (self) of
        Empty: a
        Prepend x xs: f x (xs.fold a f)

    def plus that: case (self) of
        Empty: that
        Prepend x xs: Prepend x (xs.plus that)

    def length: case (self) of
        Empty: 0
        Prepend x xs: xs.length.succ

    def shortRep: "List<" + self.length.shortRep + ">"

    def prependAll it: case (self) of
        Empty: Empty
        Prepend x xs: xs . prependAll it . prepend x . prepend it

    def intersperse sep: case (self) of
        Empty: Empty
        Prepend x xs: xs . prependAll sep . prepend x

    def toJSON: "[" + (self . map (x: x.toJSON) . intersperse "," . fold "" (+)) + "]"

    def filter f: case (self) of
         Empty: Empty
         Prepend x xs: switch (f x) (Prepend x (xs.filter f)) (xs.filter f)

    def findBy a: self.filter (x: x.head.equals (Just a))

    def findWhere pred: self.filter (x: x.head.satisfies pred)

    def values: self.map (x: x.tail.head.fromJust)

    def incAt key: case (self) of
        Empty: Prepend (Pair key 1) Empty
        Prepend (Pair k i) ls: switch (k.equals key) (Prepend (Pair k i.succ) ls) (Prepend (Pair k i) (ls.incAt key))

    def flattenScore: self.map ((Pair k v): Prepend k (Prepend v.shortRep Empty))

    def score: self . fold Empty (k: m: m.incAt k) . flattenScore
